# Edge Runtime JWT Fix

## 🐛 Problem: Edge Runtime Error

### Error Message:

```
❌ [verifyToken] Token verification failed: Error: The edge runtime does not support Node.js 'crypto' module.
Learn More: https://nextjs.org/docs/messages/node-module-in-edge-runtime
```

### Root Cause:

Next.js middleware runs in the **Edge Runtime**, which is a lightweight environment that doesn't support all Node.js modules including the `crypto` module that `jsonwebtoken` library depends on.

## ✅ Solution: Dual JWT Strategy

We now use **two different JWT libraries** depending on the context:

### 1. **jsonwebtoken** (Node.js API Routes)

- Used in: API routes (`/api/auth/*`)
- Supports: Full Node.js crypto module
- Functions: `generateToken()`, `verifyToken()`

### 2. **jose** (Edge Runtime)

- Used in: Middleware
- Supports: Edge Runtime (Web Crypto API)
- Function: `verifyTokenEdge()`

## 📝 Implementation Details

### Updated `lib/auth.ts`:

```typescript
import jwt from "jsonwebtoken"; // For Node.js API routes
import { jwtVerify } from "jose"; // For Edge Runtime (middleware)

// Node.js version - Use in API routes
export function generateToken(payload: JWTPayload): string {
  return jwt.sign(payload, JWT_SECRET, { expiresIn });
}

export function verifyToken(token: string): JWTPayload | null {
  return jwt.verify(token, JWT_SECRET) as JWTPayload;
}

// Edge Runtime version - Use in middleware
export async function verifyTokenEdge(
  token: string
): Promise<JWTPayload | null> {
  const secret = new TextEncoder().encode(JWT_SECRET);
  const { payload } = await jwtVerify(token, secret);
  return {
    userId: payload.userId as string,
    email: payload.email as string,
    role: payload.role as string,
  };
}
```

### Updated `middleware.ts`:

```typescript
import { verifyTokenEdge } from "@/lib/auth";

// Middleware is now async
export async function middleware(request: NextRequest) {
  // ...

  // Use Edge-compatible verification (async)
  const user = await verifyTokenEdge(token);

  // ...
}
```

## 🔄 Token Compatibility

Both libraries work with the same tokens because:

- ✅ Same JWT_SECRET is used
- ✅ Same payload structure
- ✅ Same signing algorithm (HS256 by default)
- ✅ Tokens generated by `jsonwebtoken` can be verified by `jose`
- ✅ Compatible with standard JWT specification

## 📊 Usage Guide

### When to use each function:

| Context                           | Function            | Library      | Runtime |
| --------------------------------- | ------------------- | ------------ | ------- |
| Sign In API (`/api/auth/signin`)  | `generateToken()`   | jsonwebtoken | Node.js |
| Session API (`/api/auth/session`) | `verifyToken()`     | jsonwebtoken | Node.js |
| tRPC Context                      | `verifyToken()`     | jsonwebtoken | Node.js |
| Middleware                        | `verifyTokenEdge()` | jose         | Edge    |

### File Locations:

**Node.js API Routes (use `verifyToken`):**

- `app/api/auth/signin/route.ts` ✅
- `app/api/auth/session/route.ts` ✅
- `app/api/trpc/[trpc]/route.ts` ✅

**Edge Runtime (use `verifyTokenEdge`):**

- `src/middleware.ts` ✅

## 🧪 Testing

After this fix:

1. **Clear all cookies**
2. **Restart dev server**: `npm run dev`
3. **Sign in again**
4. **Check console logs**:

Expected success logs:

```
✅ [SignIn] Token received
🍪 [SignIn] Cookie set, verifying: EXISTS
🔒 [Middleware] Request to: /s/hub
🔍 [Middleware] Verifying token...
🔐 [verifyTokenEdge] Verifying token with JWT_SECRET: SET
✅ [verifyTokenEdge] Token valid, decoded: { userId, email, role }
✅ [Middleware] Token valid, user: user@example.com role: JOB_SEEKER
✅ [Middleware] Allowing access to protected route
```

## 🎯 Key Differences

### jsonwebtoken (Node.js):

```typescript
// Synchronous
const decoded = jwt.verify(token, secret);
```

### jose (Edge):

```typescript
// Asynchronous
const { payload } = await jwtVerify(token, secret);

// Secret must be Uint8Array
const secret = new TextEncoder().encode(JWT_SECRET);
```

## 📦 Dependencies

Make sure these are installed:

```json
{
  "dependencies": {
    "jsonwebtoken": "^9.0.0",
    "jose": "^5.0.0"
  },
  "devDependencies": {
    "@types/jsonwebtoken": "^9.0.0"
  }
}
```

## 🔐 Security Notes

- ✅ Both libraries use the same `JWT_SECRET`
- ✅ Same security level (HS256 algorithm)
- ✅ Same token expiration handling
- ✅ Edge Runtime is actually MORE secure (isolated environment)
- ✅ No changes needed to token format or payload

## 🚀 Benefits of Edge Runtime

While the crypto module limitation seems like a constraint, Edge Runtime offers:

1. **Faster cold starts** - Smaller runtime environment
2. **Better scalability** - Distributed edge locations
3. **Lower latency** - Runs closer to users
4. **Reduced memory usage** - Lightweight runtime

## 📚 References

- [Next.js Edge Runtime](https://nextjs.org/docs/app/building-your-application/rendering/edge-and-nodejs-runtimes)
- [jose library documentation](https://github.com/panva/jose)
- [JWT specification](https://datatracker.ietf.org/doc/html/rfc7519)

## ✅ Verification Checklist

After implementing this fix:

- [x] Installed `jose` package
- [x] Created `verifyTokenEdge()` function
- [x] Updated middleware to use `verifyTokenEdge()`
- [x] Made middleware async
- [x] Kept `verifyToken()` for API routes
- [x] Both functions use same JWT_SECRET
- [x] No TypeScript errors
- [x] Tokens are compatible between both libraries

Your authentication should now work correctly in both Edge Runtime (middleware) and Node.js Runtime (API routes)! 🎉
